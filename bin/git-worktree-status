#!/bin/bash
set -e

# Color codes for better readability
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Target branch defaults to main or use first argument
target_branch="${1:-main}"

# Store the original directory
original_dir=$(pwd)

# Arrays to track worktree status
declare -a safe_to_delete=()
declare -a needs_attention=()

echo -e "Target branch: ${BLUE}$target_branch${NC}"
echo ""

# Fetch latest changes from remote
git fetch --all --prune 2>/dev/null || true

# Get list of all remote branches once (performance optimization)
remote_branches=$(git branch -r 2>/dev/null | sed 's/origin\///' | sed 's/^[[:space:]]*//' | grep -v '^HEAD' || true)

# Parse worktrees more robustly
while IFS= read -r line; do
  if [[ $line == worktree* ]]; then
    worktree_path="${line#worktree }"
  elif [[ $line == branch* ]]; then
    branch_name="${line#branch refs/heads/}"

    # Skip if this is the main worktree on the target branch
    if [[ "$branch_name" == "$target_branch" ]]; then
      continue
    fi

    # Initialize flags
    has_uncommitted=false
    has_unpushed=false
    is_merged=false
    remote_exists=true
    safe=true
    issues=()

    # Navigate to the worktree
    cd "$worktree_path" || {
      safe=false
      issues+=("inaccessible")
      needs_attention+=("$branch_name")
      cd "$original_dir"
      continue
    }

    # Get the current branch (handle detached HEAD)
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "DETACHED")

    if [[ "$current_branch" == "HEAD" ]] || [[ "$current_branch" == "DETACHED" ]]; then
      issues+=("detached HEAD")
      safe=false
    fi

    # Check if directory name matches branch name
    worktree_dirname=$(basename "$worktree_path")
    if [[ "$worktree_dirname" != "$current_branch" ]]; then
      issues+=("branch name mismatch")
      safe=false
    fi

    # Check for uncommitted changes and untracked files
    has_changes=false
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
      has_uncommitted=true
      has_changes=true
      safe=false
    fi

    # Check for untracked files
    untracked_count=$(git ls-files --others --exclude-standard | wc -l | xargs)
    if [[ $untracked_count -gt 0 ]]; then
      has_changes=true
      safe=false
    fi

    # Add combined message for uncommitted/untracked
    if [[ "$has_changes" == true ]]; then
      issues+=("uncommitted changes")
    fi

    # Skip merge/push checks if branch doesn't exist
    if ! git rev-parse --verify "$current_branch" >/dev/null 2>&1; then
      issues+=("invalid branch")
      safe=false
      needs_attention+=("$current_branch")
      cd "$original_dir"
      continue
    fi

    # Check if remote branch exists (using cached remote branches list)
    if ! echo "$remote_branches" | grep -q "^${current_branch}$"; then
      issues+=("no remote branch")
      remote_exists=false
    fi

    # Check for unpushed commits
    if [[ "$remote_exists" == true ]]; then
      unpushed_count=$(git rev-list --count "origin/$current_branch..$current_branch" 2>/dev/null || echo "0")
      if [[ $unpushed_count -gt 0 ]]; then
        has_unpushed=true
        issues+=("unpushed commits")
        safe=false
      fi
    fi

    # Check if the branch has been merged into the target branch
    # "not merged" means this branch has commits that aren't in the target branch yet
    if git merge-base --is-ancestor "$current_branch" "origin/$target_branch" 2>/dev/null; then
      # Also verify that all commits from current branch are in target
      if ! git rev-list "$current_branch" --not "origin/$target_branch" | grep -q .; then
        is_merged=true
      else
        issues+=("not merged")
        safe=false
      fi
    else
      issues+=("not merged")
      safe=false
    fi

    # Track the worktree status and print output
    if [[ "$safe" == true ]] && [[ "$is_merged" == true ]] && [[ "$has_uncommitted" == false ]]; then
      safe_to_delete+=("$current_branch")
      echo -e "${GREEN}✓${NC} $current_branch - ${GREEN}safe to delete${NC}"
    else
      needs_attention+=("$current_branch")
      # Join issues array with ", " separator
      issues_str=$(printf "%s, " "${issues[@]}")
      issues_str="${issues_str%, }"  # Remove trailing ", "
      echo -e "${YELLOW}⚠${NC} $current_branch - ${RED}$issues_str${NC}"
    fi

    # Return to original directory
    cd "$original_dir"
  fi
done < <(git worktree list --porcelain)

# Add spacing before summary
echo ""

# Print summary
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}=== Summary ===${NC}"
echo ""

if [[ ${#safe_to_delete[@]} -gt 0 ]]; then
  echo -e "${GREEN}Safe to delete (${#safe_to_delete[@]}):${NC}"
  for wt in "${safe_to_delete[@]}"; do
    echo -e "  ${GREEN}✓${NC} $wt"
  done
  echo ""
fi

if [[ ${#needs_attention[@]} -gt 0 ]]; then
  echo -e "${YELLOW}Needs attention (${#needs_attention[@]}):${NC}"
  for wt in "${needs_attention[@]}"; do
    echo -e "  ${YELLOW}⚠${NC} $wt"
  done
fi

# Return to original directory (safety check)
cd "$original_dir"
